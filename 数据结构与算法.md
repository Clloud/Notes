# 排序算法

## 常见排序算法的比较

[排序算法动画演示](https://www.cnblogs.com/onepixel/articles/7674659.html)

| 排序算法 |  平均时间复杂度  | 稳定性 |
| :------: | :--------------: | :----: |
| 冒泡排序 | O(n<sup>2</sup>) |  稳定  |
| 选择排序 | O(n<sup>2</sup>) | 不稳定 |
| 插入排序 | O(n<sup>2</sup>) |  稳定  |
| 归并排序 |     O(nlogn)     |  稳定  |
| 快速排序 |     O(nlogn)     | 不稳定 |
|  堆排序  |     O(nlogn)     | 不稳定 |

## 快速排序

```java
public class QuickSort {
    public void quickSort(int[] arr, int l, int r) {
        if (l < r) {
            int mid = partition(arr, l, r);
            quickSort(arr, l, mid - 1);
            quickSort(arr, mid + 1, r);
        }
    }

    private int partition(int[] arr, int l, int r) {
        // 选择arr[r]作为主元，对子数组arr[l..r]进行划分
        int x = arr[r];
        int i = l - 1;
        // 维持循环不变式a[l..i] < x, a[i+1..j] >= x
        for (int j = l; j <= r - 1; j++) {
            if (arr[j] < x) {
                i++;
                // 交换arr[i]和arr[j]
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        // 交换arr[i+1]与arr[r]
        int temp = arr[i+1];
        arr[i+1] = arr[r];
        arr[r] = temp;

        // 返回主元的下标
        return i + 1;
    }
}
```

## 堆排序

```java
public class HeapSort {
    public void heapSort(int[] arr) {
        buildMaxHeap(arr);
        for (int i = arr.length - 1; i >= 1; i--) {
            // 交换arr[0]和arr[i]，将堆的最大元素保存到数组末尾
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            // arr[0..i-1]为新的堆，调整堆
            maxHeapify(arr,0, i);
        }
    }

    // 自底向上建堆，时间复杂度O(n)
    private void buildMaxHeap(int[] arr) {
        for (int i = arr.length / 2; i >= 0; i--) {
            maxHeapify(arr, i, arr.length);
        }
    }

    // 维护最大堆的性质
    private void maxHeapify(int[] arr, int i, int heapSize) {
        // 找出arr[i]、arr[i]的左节点、右节点这三者的最大值
        int l = 2 * i + 1;
        int r = 2 * i + 2;
        int largest = i;
        if (l < heapSize && arr[l] > arr[i])
            largest = l;
        if (r < heapSize && arr[r] > arr[largest])
            largest = r;

        if (largest != i) {
            // 交换arr[i]和arr[largest]
            int temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;
            // 继续调整节点
            maxHeapify(arr, largest, heapSize);
        }
    }
}
```

## 归并排序

```java
public class MergeSort {
    public void mergeSort(int[] arr, int l, int r) {
        if (l < r) {
            int mid = (l + r) / 2;
            mergeSort(arr, l, mid);
            mergeSort(arr, mid+1, r);
            merge(arr, l, mid, r);
        }
    }

    // 合并两个有序数组arr[l..mid] arr[mid+1..r]
    private void merge(int arr[], int l, int mid, int r) {
        // 将arr[]中的左右两个有序子数组拷贝到新的数组中
        int n1 = mid - l + 1;
        int n2 = r - mid;
        int[] L = new int[n1+1];
        int[] R = new int[n2+1];
        for (int i = 0; i < n1; i++)
            L[i] = arr[l+i];
        for (int j = 0; j < n2; j++)
            R[j] = arr[mid+1+j];
        // 在两个数组最后各加上一个哨兵
        L[n1] = Integer.MAX_VALUE;
        R[n2] = Integer.MAX_VALUE;

        // 合并两个有序数组
        int i = 0, j = 0;
        for (int k = l; k <= r; k++) {
            if (L[i] < R[j]) {
                arr[k] = L[i];
                i++;
            }
            else {
                arr[k] = R[j];
                j++;
            }
        }
    }
}
```

二分查找

